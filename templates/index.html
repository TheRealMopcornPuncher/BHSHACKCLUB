{% extends "layout.html" %}

{% block title %}Welcome to BHS Hack Club{% endblock %}

{% block content %}
<div class="container centered_text_box slide-up">
    <h1>Welcome to the BHS Hack Club website!</h1>
    <p>This is the official website of the BHS Hack Club, programmed BY the BHS Hack Club! We are a group of students who are passionate about technology and programming. We meet every week to learn new things, work on projects, and have fun!</p>
    <p>Feel free to explore our website to learn more about us, our events, and the resources we offer. If you are interested in joining us, please contact us or come to one of our meetings!</p>
</div>

<!-- Three.js Example -->
<div id="three-container"></div>
{% endblock %}

{% block scripts %}
<script type="module">
    import * as THREE from '/static/js/three.module.js';
    import { EffectComposer } from '/static/js/postprocessing/EffectComposer.js';
    import { RenderPass } from '/static/js/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from '/static/js/postprocessing/UnrealBloomPass.js';

    // Function to check for WebGL support and hardware acceleration
    function isHardwareAccelerated() {
        try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) return false;

            // Check for specific renderer information
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            const renderer = debugInfo
                ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
                : gl.getParameter(gl.RENDERER);

            console.log(`Renderer: ${renderer}`);

            // Check for software rendering terms
            const isSoftwareRendering = /swiftshader|software|webkit/i.test(renderer);
            return !isSoftwareRendering;
        } catch (e) {
            console.error('Error checking hardware acceleration:', e);
            return false;
        }
    }

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 15); // Adjusted to view the grid properly
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.physicallyCorrectLights = true;

    // Add the renderer's canvas to the #three-container
    const threeContainer = document.getElementById('three-container');
    if (!threeContainer) {
        console.error('three-container element not found');
    } else {
        threeContainer.appendChild(renderer.domElement);
    }

    // Check if hardware acceleration is enabled
    const bloomEnabled = isHardwareAccelerated();
    console.log(`Bloom Enabled: ${bloomEnabled}`);
    if (!bloomEnabled) {
        console.warn('Hardware acceleration not detected. Disabling bloom effect.');
    }


    // Set up EffectComposer with proper render target configuration
    let composer = null;
    if (bloomEnabled) {
        const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
            format: THREE.RGBAFormat,
            depthBuffer: true,
        });
        renderTarget.texture.minFilter = THREE.LinearFilter;

        composer = new EffectComposer(renderer, renderTarget);
        composer.setSize(window.innerWidth, window.innerHeight);
        composer.addPass(new RenderPass(scene, camera));

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, // strength
            0.4, // radius
            0.1  // threshold
        );
        composer.addPass(bloomPass);
    }

    // Geometry and Material for each point
    const geometry = new THREE.SphereGeometry(0.2, 16, 16);
    const material = new THREE.MeshStandardMaterial({
        emissive: new THREE.Color(0x34eb64),
        emissiveIntensity: 1.0,
        metalness: 0.5,
        roughness: 0.5
    });

    // Create a 3x3 grid of points
    const points = [];
    const gridSize = 3;
    const spacing = 2;

    for (let x = -1; x <= 1; x++) {
        for (let z = -1; z <= 1; z++) {
            const point = new THREE.Mesh(geometry, material);
            point.position.set(x * spacing, 0, z * spacing);
            scene.add(point);
            points.push(point);
        }
    }

    // Lighting
    const light = new THREE.PointLight(0xffffff, 1, 100);
    light.position.set(5, 10, 5);
    scene.add(light);

    // Animation loop
    let time = 0;
    function animate() {
        time += 0.02;

        // Animate the points
        points.forEach((point) => {
            const x = point.position.x;
            const z = point.position.z;
            point.position.y = Math.sin((x + time) * 0.5) + Math.cos((z + time) * 0.5);
        });

        if (bloomEnabled) {
            composer.render();
        } else {
            renderer.render(scene, camera);
        }

        requestAnimationFrame(animate);
    }
    animate();

    // Handle window resizing
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
        if (bloomEnabled) composer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
{% endblock %}
